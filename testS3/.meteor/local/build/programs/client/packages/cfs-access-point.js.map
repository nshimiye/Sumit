)]}'
{"version":3,"file":"/packages/cfs-access-point.js","sources":["cfs-access-point/access-point-common.js","cfs-access-point/access-point-client.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,iB;AACA,wB;;AAEA,uE;AACA,uC;;AAEA,G;AACA,6B;AACA,U;AACA,0F;AACA,uB;AACA,G;AACA,sD;;AAEA,oC;AACA,uC;AACA,kC;AACA,G;AACA,qC;AACA,yC;AACA,G;;AAEA,wB;AACA,uB;;AAEA,2E;AACA,yC;;AAEA,+E;AACA,4E;AACA,gF;AACA,qE;AACA,gB;AACA,G;AACA,E;;AAEA,E;AACA,qB;AACA,G;;AAEA,G;AACA,uD;AACA,U;AACA,4B;AACA,iF;AACA,0E;AACA,sE;AACA,sF;AACA,uE;AACA,6E;AACA,2B;AACA,E;AACA,8E;AACA,yD;AACA,G;AACA,2C;AACA,kB;AACA,0B;AACA,+B;AACA,gB;AACA,e;AACA,oB;AACA,oB;AACA,wB;AACA,uD;AACA,mD;AACA,qE;AACA,2E;;AAEA,+E;AACA,gD;AACA,6B;AACA,G;;AAEA,yB;AACA,qD;AACA,uE;AACA,qC;AACA,4B;AACA,+B;AACA,yC;AACA,qE;AACA,wE;AACA,uB;AACA,oB;AACA,O;AACA,K;;AAEA,yD;AACA,qE;AACA,0D;AACA,gC;AACA,Y;AACA,oB;AACA,K;;AAEA,0E;AACA,uB;AACA,iH;AACA,mC;AACA,wC;AACA,wB;;AAEA,0B;AACA,uD;AACA,U;;AAEA,4E;AACA,6C;AACA,sE;AACA,S;;AAEA,4B;AACA,oD;AACA,gD;AACA,O;AACA,kD;AACA,yE;AACA,iB;AACA,+B;AACA,K;;AAEA,6B;AACA,oB;AACA,2B;AACA,+B;AACA,K;AACA,2B;AACA,6B;AACA,K;AACA,wB;AACA,+F;AACA,6F;AACA,4F;AACA,6F;AACA,yC;AACA,mC;AACA,K;AACA,sD;AACA,6B;AACA,sC;AACA,K;;AAEA,iC;AACA,a;AACA,2B;AACA,uB;AACA,Y;AACA,sB;AACA,K;;AAEA,+C;AACA,iG;AACA,G;;AAEA,E;;;;;;;;;;;;;;;;;;;;;AC3JA,wD;AACA,gB;AACA,E;;AAEA,0B;AACA,8C;AACA,E;;AAEA,oD;AACA,kC;AACA,wD;AACA,+B;AACA,c;AACA,W;AACA,U;AACA,O;AACA,iB;AACA,sD;AACA,0C;AACA,4B;AACA,e;AACA,sB;AACA,K;AACA,c;AACA,0D;AACA,mB;AACA,G;;AAEA,iB;AACA,E;;AAEA,2B;AACA,qC;;AAEA,4B;;AAEA,qD;;AAEA,sB;AACA,2C;AACA,yF;AACA,2E;AACA,iD;AACA,6B;AACA,gD;AACA,yD;AACA,mB;AACA,sC;AACA,gD;AACA,+E;AACA,kC;AACA,uF;AACA,c;AACA,kC;AACA,O;AACA,yB;AACA,K;AACA,C","sourcesContent":["baseUrl = '/cfs';\nFS.HTTP = FS.HTTP || {};\n\n// Note the upload URL so that client uploader packages know what it is\nFS.HTTP.uploadUrl = baseUrl + '/files';\n\n/**\n * @method FS.HTTP.setBaseUrl\n * @public\n * @param {String} newBaseUrl - Change the base URL for the HTTP GET and DELETE endpoints.\n * @returns {undefined}\n */\nFS.HTTP.setBaseUrl = function setBaseUrl(newBaseUrl) {\n\n  // Adjust the baseUrl if necessary\n  if (newBaseUrl.slice(0, 1) !== '/') {\n    newBaseUrl = '/' + newBaseUrl;\n  }\n  if (newBaseUrl.slice(-1) === '/') {\n    newBaseUrl = newBaseUrl.slice(0, -1);\n  }\n\n  // Update the base URL\n  baseUrl = newBaseUrl;\n\n  // Change the upload URL so that client uploader packages know what it is\n  FS.HTTP.uploadUrl = baseUrl + '/files';\n\n  // Remount URLs with the new baseUrl, unmounting the old, on the server only.\n  // If existingMountPoints is empty, then we haven't run the server startup\n  // code yet, so this new URL will be used at that point for the initial mount.\n  if (Meteor.isServer && !FS.Utility.isEmpty(_existingMountPoints)) {\n    mountUrls();\n  }\n};\n\n/*\n * FS.File extensions\n */\n\n/**\n * @method FS.File.prototype.url Construct the file url\n * @public\n * @param {object} [options]\n * @param {string} [options.store] Name of the store to get from. If not defined,\n * the first store defined in `options.stores` for the collection is used.\n * @param {boolean} [options.auth=null] Wether or not the authenticate\n * @param {boolean} [options.download=false] Should headers be set to force a download\n * @param {boolean} [options.brokenIsFine=false] Return the URL even if\n * we know it's currently a broken link because the file hasn't been saved in\n * the requested store yet.\n *\n * Return the http url for getting the file - on server set auth if wanting to\n * use authentication on client set auth to true or token\n */\nFS.File.prototype.url = function(options) {\n  var self = this;\n  options = options || {};\n  options = FS.Utility.extend({\n    store: null,\n    auth: null,\n    download: false,\n    metadata: false,\n    brokenIsFine: false,\n    uploading: null, // return this URL while uploading\n    storing: null, // return this URL while storing\n    filename: null // override the filename that is shown to the user\n  }, options.hash || options); // check for \"hash\" prop if called as helper\n\n  // Primarily useful for displaying a temporary image while uploading an image\n  if (options.uploading && !self.isUploaded()) {\n    return options.uploading;\n  }\n\n  if (self.isMounted()) {\n    // See if we've stored in the requested store yet\n    var storeName = options.store || self.collection.primaryStore.name;\n    if (!self.hasStored(storeName)) {\n      if (options.storing) {\n        return options.storing;\n      } else if (!options.brokenIsFine) {\n        // We want to return null if we know the URL will be a broken\n        // link because then we can avoid rendering broken links, broken\n        // images, etc.\n        return null;\n      }\n    }\n\n    // Add filename to end of URL if we can determine one\n    var filename = options.filename || self.name({store: storeName});\n    if (typeof filename === \"string\" && filename.length) {\n      filename = '/' + filename;\n    } else {\n      filename = '';\n    }\n\n    // TODO: Could we somehow figure out if the collection requires login?\n    var authToken = '';\n    if (Meteor.isClient && typeof Accounts !== \"undefined\" && typeof Accounts._storedLoginToken === \"function\") {\n      if (options.auth !== false) {\n        // Add reactive deps on the user\n        Meteor.userId();\n\n        var authObject = {\n          authToken: Accounts._storedLoginToken() || ''\n        };\n\n        // If it's a number, we use that as the expiration time (in seconds)\n        if (options.auth === +options.auth) {\n          authObject.expiration = FS.HTTP.now() + options.auth * 1000;\n        }\n\n        // Set the authToken\n        var authString = JSON.stringify(authObject);\n        authToken = FS.Utility.btoa(authString);\n      }\n    } else if (typeof options.auth === \"string\") {\n      // If the user supplies auth token the user will be responsible for\n      // updating\n      authToken = options.auth;\n    }\n\n    // Construct query string\n    var params = {};\n    if (authToken !== '') {\n      params.token = authToken;\n    }\n    if (options.download) {\n      params.download = true;\n    }\n    if (options.store) {\n      // We use options.store here instead of storeName because we want to omit the queryString\n      // whenever possible, allowing users to have \"clean\" URLs if they want. The server will\n      // assume the first store defined on the server, which means that we are assuming that\n      // the first on the client is also the first on the server. If that's not the case, the\n      // store option should be supplied.\n      params.store = options.store;\n    }\n    var queryString = FS.Utility.encodeParams(params);\n    if (queryString.length) {\n      queryString = '?' + queryString;\n    }\n\n    // Determine which URL to use\n    var area;\n    if (options.metadata) {\n      area = '/record';\n    } else {\n      area = '/files';\n    }\n\n    // Construct and return the http method url\n    return baseUrl + area + '/' + self.collection.name + '/' + self._id + filename + queryString;\n  }\n\n};\n\n\n","FS.HTTP.setHeadersForGet = function setHeadersForGet() {\n  // Client Stub\n};\n\nFS.HTTP.now = function() {\n  return Date.now() + FS.HTTP._serverTimeDiff;\n};\n\n// Returns the localstorage if its found and working\n// TODO: check if this works in IE\n// could use Meteor._localStorage - just needs a rewrite\nFS.HTTP._storage = function() {\n  var storage,\n      fail,\n      uid;\n  try {\n    uid = \"test\";\n    (storage = window.localStorage).setItem(uid, uid);\n    fail = (storage.getItem(uid) !== uid);\n    storage.removeItem(uid);\n    if (fail) {\n      storage = false;\n    }\n  } catch(e) {\n    console.log(\"Error initializing storage for FS.HTTP\");\n    console.log(e);\n  }\n\n  return storage;\n};\n\n// get our storage if found\nFS.HTTP.storage = FS.HTTP._storage();\n\nFS.HTTP._prefix = 'fsHTTP.';\n\nFS.HTTP._serverTimeDiff = 0; // Time difference in ms\n\nif (FS.HTTP.storage) {\n  // Initialize the FS.HTTP._serverTimeDiff\n  FS.HTTP._serverTimeDiff = (1*FS.HTTP.storage.getItem(FS.HTTP._prefix+'timeDiff')) || 0;\n  // At client startup we figure out the time difference between server and\n  // client time - this includes lag and timezone\n  Meteor.startup(function() {\n    // Call the server method an get server time\n    HTTP.get('/cfs/servertime', function(error, result) {\n      if (!error) {\n        // Update our server time diff\n        var dateNew = new Date(+result.content);\n        FS.HTTP._serverTimeDiff = dateNew - Date.now();// - lag or/and timezone\n        // Update the localstorage\n        FS.HTTP.storage.setItem(FS.HTTP._prefix + 'timeDiff', FS.HTTP._serverTimeDiff);\n      } else {\n      \tconsole.log(error.message);\n      }\n    }); // EO Server call\n  });\n}\n"]}