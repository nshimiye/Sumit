)]}'
{"version":3,"file":"/packages/data-man.js","sources":["data-man/client/Blob.js","data-man/client/data-man-api.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,U;AACA,yB;AACA,a;AACA,E;AACA,kC;AACA,8C;AACA,mB;AACA,mB;AACA,G;;AAEA,0B;AACA,0F;AACA,mB;;AAEA,yE;;AAEA,4F;AACA,uH;AACA,kC;AACA,iB;;AAEA,kI;AACA,W;AACA,4C;AACA,6F;AACA,a;AACA,wD;AACA,+B;AACA,a;AACA,8D;AACA,iC;AACA,wC;AACA,iC;AACA,yC;AACA,a;AACA,mD;AACA,2C;AACA,kD;AACA,8C;AACA,mD;AACA,a;AACA,+B;AACA,uF;AACA,4E;AACA,wB;AACA,iD;AACA,2D;AACA,+D;AACA,+D;AACA,4B;AACA,8B;AACA,8B;;AAEA,4C;AACA,0C;AACA,S;AACA,6C;AACA,gC;AACA,oF;AACA,S;AACA,wC;AACA,gC;AACA,S;AACA,8C;AACA,e;AACA,kC;AACA,iC;AACA,a;AACA,gC;AACA,kD;AACA,a;AACA,2C;AACA,iD;AACA,iD;AACA,oE;AACA,qD;AACA,iF;AACA,6B;AACA,0E;AACA,wB;AACA,iF;AACA,iB;AACA,gD;AACA,mE;AACA,a;AACA,U;AACA,oD;AACA,mF;AACA,kE;AACA,a;AACA,U;AACA,wD;AACA,+B;AACA,6C;AACA,4F;AACA,mB;AACA,8B;AACA,gD;AACA,2B;AACA,0C;AACA,iB;AACA,0C;AACA,uD;AACA,iB;AACA,6B;AACA,kF;AACA,qC;AACA,gD;AACA,yD;AACA,wB;AACA,yE;AACA,gE;AACA,iB;AACA,kD;AACA,yD;AACA,6C;AACA,qD;AACA,2D;AACA,qD;AACA,uC;AACA,iB;AACA,oB;AACA,+C;AACA,uE;AACA,iB;AACA,iD;AACA,4D;AACA,a;AACA,U;AACA,4C;AACA,oC;AACA,4B;AACA,a;AACA,iE;AACA,U;AACA,yC;AACA,0C;AACA,U;AACA,qD;AACA,wC;AACA,2B;AACA,4B;AACA,a;AACA,gC;AACA,2E;AACA,sB;AACA,+B;AACA,c;AACA,U;AACA,wC;AACA,mC;AACA,U;AACA,+B;AACA,a;;AAEA,8C;AACA,uD;AACA,wC;AACA,wB;AACA,mE;AACA,6C;AACA,a;AACA,S;AACA,qC;AACA,M;AACA,2G;;;;;;;;;;;;;;;;;;;ACrKA,G;AACA,kB;AACA,U;AACA,e;AACA,8F;AACA,sI;AACA,G;AACA,wC;AACA,kB;;AAEA,c;AACA,oE;AACA,G;;AAEA,8E;AACA,gB;AACA,e;AACA,8E;AACA,qE;AACA,4D;AACA,8D;AACA,2B;AACA,mE;AACA,qB;AACA,2B;AACA,yG;AACA,sC;AACA,2F;AACA,K;AACA,gB;AACA,+G;AACA,K;AACA,+C;AACA,sB;AACA,wC;AACA,uC;AACA,oD;AACA,kD;AACA,+E;AACA,kB;AACA,0F;AACA,O;AACA,sB;AACA,wB;AACA,Y;AACA,+E;AACA,K;AACA,U;AACA,iF;AACA,G;AACA,E;;AAEA,G;AACA,oC;AACA,U;AACA,uD;AACA,4B;AACA,E;AACA,gE;AACA,8D;AACA,+B;AACA,G;AACA,+D;AACA,kB;;AAEA,iB;AACA,oB;AACA,gC;AACA,0B;AACA,qC;AACA,sC;AACA,gC;AACA,mC;AACA,iC;AACA,kC;AACA,Q;AACA,mC;AACA,sB;AACA,Q;AACA,iB;AACA,K;AACA,U;AACA,iB;AACA,iF;AACA,qB;AACA,G;AACA,E;;AAEA,G;AACA,sC;AACA,U;AACA,yD;AACA,sD;AACA,2D;AACA,uB;AACA,E;AACA,4D;AACA,G;AACA,+E;AACA,kB;;AAEA,oC;AACA,qB;AACA,G;AACA,yC;;AAEA,uB;AACA,4C;AACA,iE;AACA,a;AACA,K;;AAEA,kC;AACA,mC;AACA,wD;AACA,M;AACA,oC;AACA,oB;AACA,M;AACA,mC;AACA,G;;AAEA,uC;AACA,gB;AACA,sB;AACA,Y;AACA,iE;AACA,6B;AACA,oD;AACA,4B;AACA,qG;AACA,iB;AACA,S;AACA,kC;;AAEA,oE;AACA,2C;AACA,qE;AACA,iB;AACA,S;;AAEA,uD;AACA,c;AACA,wC;AACA,mB;AACA,O;AACA,K;AACA,K;;AAEA,E;;AAEA,oC;AACA,U;AACA,6B;AACA,sB;AACA,E;AACA,oE;AACA,+B;AACA,E;AACA,G;AACA,6D;AACA,kB;;AAEA,oC;AACA,+D;;AAEA,uB;AACA,4G;AACA,W;AACA,G;;AAEA,uC;AACA,gB;AACA,kB;AACA,Y;AACA,oC;AACA,K;AACA,K;AACA,E;;AAEA,G;AACA,uC;AACA,U;AACA,oD;AACA,G;AACA,qE;AACA,6D;AACA,qE;AACA,2E;AACA,6E;;AAEA,kB;;AAEA,qC;AACA,6D;;AAEA,0C;AACA,+D;AACA,W;AACA,G;;AAEA,oC;AACA,uC;AACA,sC;AACA,4B;AACA,I;AACA,sC;AACA,kB;AACA,I;;AAEA,uC;AACA,gB;AACA,sB;AACA,Y;AACA,qC;AACA,K;AACA,K;AACA,E;;AAEA,G;AACA,iC;AACA,U;AACA,mD;AACA,E;AACA,4D;AACA,gF;AACA,G;AACA,yD;AACA,kB;;AAEA,iB;AACA,yC;AACA,iC;AACA,Y;AACA,2C;AACA,oB;AACA,0B;AACA,gB;AACA,iC;AACA,qC;AACA,S;AACA,S;AACA,K;AACA,U;AACA,mB;AACA,mH;AACA,gD;AACA,wB;AACA,Y;AACA,gC;AACA,6B;AACA,wB;AACA,K;AACA,G;AACA,E;;AAEA,G;AACA,iC;AACA,U;AACA,E;AACA,gC;AACA,G;AACA,iD;AACA,oB;AACA,E;;AAEA,G;AACA,wB;AACA,W;AACA,uC;AACA,4C;AACA,sC;AACA,E;AACA,iC;AACA,G;AACA,2C;AACA,oD;AACA,oE;AACA,6D;AACA,C;;AAEA,G;AACA,0B;AACA,W;AACA,uB;AACA,uB;AACA,E;AACA,6E;AACA,oD;AACA,G;AACA,+B;AACA,Y;AACA,wC;AACA,sC;AACA,iC;AACA,Y;AACA,uC;AACA,gB;AACA,K;;AAEA,G;AACA,C","sourcesContent":["/* Blob.js\n * A Blob implementation.\n * 2013-12-27\n *\n * By Eli Grey, http://eligrey.com\n * By Devin Samarin, https://github.com/eboyjr\n * License: X11/MIT\n *   See LICENSE.md\n */\n\n/*global self, unescape */\n/*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,\n  plusplus: true */\n\n/*! @source http://purl.eligrey.com/github/Blob.js/blob/master/Blob.js */\n\nif (!(typeof Blob === \"function\" || typeof Blob === \"object\") || typeof URL === \"undefined\")\nif ((typeof Blob === \"function\" || typeof Blob === \"object\") && typeof webkitURL !== \"undefined\") self.URL = webkitURL;\nelse var Blob = (function (view) {\n    \"use strict\";\n\n    var BlobBuilder = view.BlobBuilder || view.WebKitBlobBuilder || view.MozBlobBuilder || view.MSBlobBuilder || (function(view) {\n        var\n              get_class = function(object) {\n                return Object.prototype.toString.call(object).match(/^\\[object\\s(.*)\\]$/)[1];\n            }\n            , FakeBlobBuilder = function BlobBuilder() {\n                this.data = [];\n            }\n            , FakeBlob = function Blob(data, type, encoding) {\n                this.data = data;\n                this.size = data.length;\n                this.type = type;\n                this.encoding = encoding;\n            }\n            , FBB_proto = FakeBlobBuilder.prototype\n            , FB_proto = FakeBlob.prototype\n            , FileReaderSync = view.FileReaderSync\n            , FileException = function(type) {\n                this.code = this[this.name = type];\n            }\n            , file_ex_codes = (\n                  \"NOT_FOUND_ERR SECURITY_ERR ABORT_ERR NOT_READABLE_ERR ENCODING_ERR \"\n                + \"NO_MODIFICATION_ALLOWED_ERR INVALID_STATE_ERR SYNTAX_ERR\"\n            ).split(\" \")\n            , file_ex_code = file_ex_codes.length\n            , real_URL = view.URL || view.webkitURL || view\n            , real_create_object_URL = real_URL.createObjectURL\n            , real_revoke_object_URL = real_URL.revokeObjectURL\n            , URL = real_URL\n            , btoa = view.btoa\n            , atob = view.atob\n\n            , ArrayBuffer = view.ArrayBuffer\n            , Uint8Array = view.Uint8Array\n        ;\n        FakeBlob.fake = FB_proto.fake = true;\n        while (file_ex_code--) {\n            FileException.prototype[file_ex_codes[file_ex_code]] = file_ex_code + 1;\n        }\n        if (!real_URL.createObjectURL) {\n            URL = view.URL = {};\n        }\n        URL.createObjectURL = function(blob) {\n            var\n                  type = blob.type\n                , data_URI_header\n            ;\n            if (type === null) {\n                type = \"application/octet-stream\";\n            }\n            if (blob instanceof FakeBlob) {\n                data_URI_header = \"data:\" + type;\n                if (blob.encoding === \"base64\") {\n                    return data_URI_header + \";base64,\" + blob.data;\n                } else if (blob.encoding === \"URI\") {\n                    return data_URI_header + \",\" + decodeURIComponent(blob.data);\n                } if (btoa) {\n                    return data_URI_header + \";base64,\" + btoa(blob.data);\n                } else {\n                    return data_URI_header + \",\" + encodeURIComponent(blob.data);\n                }\n            } else if (real_create_object_URL) {\n                return real_create_object_URL.call(real_URL, blob);\n            }\n        };\n        URL.revokeObjectURL = function(object_URL) {\n            if (object_URL.substring(0, 5) !== \"data:\" && real_revoke_object_URL) {\n                real_revoke_object_URL.call(real_URL, object_URL);\n            }\n        };\n        FBB_proto.append = function(data/*, endings*/) {\n            var bb = this.data;\n            // decode data to a binary string\n            if (Uint8Array && (data instanceof ArrayBuffer || data instanceof Uint8Array)) {\n                var\n                      str = \"\"\n                    , buf = new Uint8Array(data)\n                    , i = 0\n                    , buf_len = buf.length\n                ;\n                for (; i < buf_len; i++) {\n                    str += String.fromCharCode(buf[i]);\n                }\n                bb.push(str);\n            } else if (get_class(data) === \"Blob\" || get_class(data) === \"File\") {\n                if (FileReaderSync) {\n                    var fr = new FileReaderSync;\n                    bb.push(fr.readAsBinaryString(data));\n                } else {\n                    // async FileReader won't work as BlobBuilder is sync\n                    throw new FileException(\"NOT_READABLE_ERR\");\n                }\n            } else if (data instanceof FakeBlob) {\n                if (data.encoding === \"base64\" && atob) {\n                    bb.push(atob(data.data));\n                } else if (data.encoding === \"URI\") {\n                    bb.push(decodeURIComponent(data.data));\n                } else if (data.encoding === \"raw\") {\n                    bb.push(data.data);\n                }\n            } else {\n                if (typeof data !== \"string\") {\n                    data += \"\"; // convert unsupported types to strings\n                }\n                // decode UTF-16 to binary string\n                bb.push(unescape(encodeURIComponent(data)));\n            }\n        };\n        FBB_proto.getBlob = function(type) {\n            if (!arguments.length) {\n                type = null;\n            }\n            return new FakeBlob(this.data.join(\"\"), type, \"raw\");\n        };\n        FBB_proto.toString = function() {\n            return \"[object BlobBuilder]\";\n        };\n        FB_proto.slice = function(start, end, type) {\n            var args = arguments.length;\n            if (args < 3) {\n                type = null;\n            }\n            return new FakeBlob(\n                  this.data.slice(start, args > 1 ? end : this.data.length)\n                , type\n                , this.encoding\n            );\n        };\n        FB_proto.toString = function() {\n            return \"[object Blob]\";\n        };\n        return FakeBlobBuilder;\n    }(view));\n\n    return function Blob(blobParts, options) {\n        var type = options ? (options.type || \"\") : \"\";\n        var builder = new BlobBuilder();\n        if (blobParts) {\n            for (var i = 0, len = blobParts.length; i < len; i++) {\n                builder.append(blobParts[i]);\n            }\n        }\n        return builder.getBlob(type);\n    };\n}(typeof self !== \"undefined\" && self || typeof window !== \"undefined\" && window || this.content || this));\n","/**\n * @method DataMan\n * @public\n * @constructor\n * @param {File|Blob|ArrayBuffer|Uint8Array|String} data The data that you want to manipulate.\n * @param {String} [type] The data content (MIME) type, if known. Required if the first argument is an ArrayBuffer, Uint8Array, or URL\n */\nDataMan = function DataMan(data, type) {\n  var self = this;\n\n  if (!data) {\n    throw new Error(\"DataMan constructor requires a data argument\");\n  }\n\n  // The end result of all this is that we will have one of the following set:\n  // - self.blob\n  // - self.url\n  // Unless we already have in-memory data, we don't load anything into memory\n  // and instead rely on obtaining a read stream when the time comes.\n  if (typeof File !== \"undefined\" && data instanceof File) {\n    self.blob = data; // File inherits from Blob so this is OK\n    self._type = data.type;\n  } else if (typeof Blob !== \"undefined\" && data instanceof Blob) {\n    self.blob = data;\n    self._type = data.type;\n  } else if (typeof ArrayBuffer !== \"undefined\" && data instanceof ArrayBuffer || EJSON.isBinary(data)) {\n    if (typeof Blob === \"undefined\") {\n      throw new Error(\"Browser must support Blobs to handle an ArrayBuffer or Uint8Array\");\n    }\n    if (!type) {\n      throw new Error(\"DataMan constructor requires a type argument when passed an ArrayBuffer or Uint8Array\");\n    }\n    self.blob = new Blob([data], {type: type});\n    self._type = type;\n  } else if (typeof data === \"string\") {\n    if (data.slice(0, 5) === \"data:\") {\n      self._type = data.slice(5, data.indexOf(';'));\n      self.blob = dataURItoBlob(data, self._type);\n    } else if (data.slice(0, 5) === \"http:\" || data.slice(0, 6) === \"https:\") {\n      if (!type) {\n        throw new Error(\"DataMan constructor requires a type argument when passed a URL\");\n      }\n      self.url = data;\n      self._type = type;\n    } else {\n      throw new Error(\"DataMan constructor received unrecognized data string\");\n    }\n  } else {\n    throw new Error(\"DataMan constructor received data that it doesn't support\");\n  }\n};\n\n/**\n * @method DataMan.prototype.getBlob\n * @public\n * @param {Function} [callback] - callback(error, blob)\n * @returns {undefined|Blob}\n *\n * Passes a Blob representing this data to a callback or returns\n * the Blob if no callback is provided. A callback is required\n * if getting a Blob for a URL.\n */\nDataMan.prototype.getBlob = function dataManGetBlob(callback) {\n  var self = this;\n\n  if (callback) {\n    if (self.blob) {\n      callback(null, self.blob);\n    } else if (self.url) {\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', self.url, true);\n      xhr.responseType = \"blob\";\n      xhr.onload = function(data) {\n        self.blob = xhr.response;\n        callback(null, self.blob);\n      };\n      xhr.onerror = function(err) {\n        callback(err);\n      };\n      xhr.send();\n    }\n  } else {\n    if (self.url)\n      throw new Error('DataMan.getBlob requires a callback when managing a URL');\n    return self.blob;\n  }\n};\n\n/**\n * @method DataMan.prototype.getBinary\n * @public\n * @param {Number} [start] - First byte position to read.\n * @param {Number} [end] - Last byte position to read.\n * @param {Function} callback - callback(error, binaryData)\n * @returns {undefined}\n *\n * Passes a Uint8Array representing this data to a callback.\n */\nDataMan.prototype.getBinary = function dataManGetBinary(start, end, callback) {\n  var self = this;\n\n  if (typeof start === \"function\") {\n    callback = start;\n  }\n  callback = callback || defaultCallback;\n\n  function read(blob) {\n    if (typeof FileReader === \"undefined\") {\n      callback(new Error(\"Browser does not support FileReader\"));\n      return;\n    }\n\n    var reader = new FileReader();\n    reader.onload = function(evt) {\n      callback(null, new Uint8Array(evt.target.result));\n    };\n    reader.onerror = function(err) {\n      callback(err);\n    };\n    reader.readAsArrayBuffer(blob);\n  }\n\n  self.getBlob(function (error, blob) {\n    if (error) {\n      callback(error);\n    } else {\n      if (typeof start === \"number\" && typeof end === \"number\") {\n        var size = blob.size;\n        // Return the requested chunk of binary data\n        if (start >= size) {\n          callback(new Error(\"DataMan.getBinary: start position beyond end of data (\" + size + \")\"));\n          return;\n        }\n        end = Math.min(size, end);\n\n        var slice = blob.slice || blob.webkitSlice || blob.mozSlice;\n        if (typeof slice === 'undefined') {\n          callback(new Error('Browser does not support File.slice'));\n          return;\n        }\n\n        read(slice.call(blob, start, end, self._type));\n      } else {\n        // Return the entire binary data\n        read(blob);\n      }\n    }\n  });\n\n};\n\n/** @method DataMan.prototype.saveAs\n * @public\n * @param {String} [filename]\n * @return {undefined}\n *\n * Tells the browser to save the data like a normal downloaded file,\n * using the provided filename.\n *\n */\nDataMan.prototype.saveAs = function dataManSaveAs(filename) {\n  var self = this;\n\n  if (typeof window === \"undefined\")\n    throw new Error(\"window must be defined to use saveLocal\");\n\n  if (!window.saveAs) {\n    console.warn('DataMan.saveAs: window.saveAs not supported by this browser - add cfs-filesaver package');\n    return;\n  }\n\n  self.getBlob(function (error, blob) {\n    if (error) {\n      throw error;\n    } else {\n      window.saveAs(blob, filename);\n    }\n  });\n};\n\n/**\n * @method DataMan.prototype.getDataUri\n * @public\n * @param {function} callback callback(err, dataUri)\n */\nDataMan.prototype.getDataUri = function dataManGetDataUri(callback) {\n  // XXX: We could consider using: URL.createObjectURL(blob);\n  // This will create a reference to the blob data instead of a clone\n  // This is part of the File API - as the rest - Not sure how to generally\n  // support from IE10, FF26, Chrome 31, safari 7, opera 19, ios 6, android 4\n\n  var self = this;\n\n  if (typeof callback !== 'function')\n    throw new Error(\"getDataUri requires callback function\");\n\n  if (typeof FileReader === \"undefined\") {\n    callback(new Error(\"Browser does not support FileReader\"));\n    return;\n  }\n\n  var fileReader = new FileReader();\n  fileReader.onload = function(event) {\n    var dataUri = event.target.result;\n    callback(null, dataUri);\n  };\n  fileReader.onerror = function(err) {\n    callback(err);\n  };\n\n  self.getBlob(function (error, blob) {\n    if (error) {\n      callback(error);\n    } else {\n      fileReader.readAsDataURL(blob);\n    }\n  });\n};\n\n/**\n * @method DataMan.prototype.size\n * @public\n * @param {function} [callback] callback(err, size)\n *\n * Passes the size of the data to the callback, if provided,\n * or returns it. A callback is required to get the size of a URL on the client.\n */\nDataMan.prototype.size = function dataManSize(callback) {\n  var self = this;\n\n  if (callback) {\n    if (typeof self._size === \"number\") {\n      callback(null, self._size);\n    } else {\n      self.getBlob(function (error, blob) {\n        if (error) {\n          callback(error);\n        } else {\n          self._size = blob.size;\n          callback(null, self._size);\n        }\n      });\n    }\n  } else {\n    if (self.url) {\n      throw new Error(\"On the client, DataMan.size requires a callback when getting size for a URL on the client\");\n    } else if (typeof self._size === \"number\") {\n      return self._size;\n    } else {\n      var blob = self.getBlob();\n      self._size = blob.size;\n      return self._size;\n    }\n  }\n};\n\n/**\n * @method DataMan.prototype.type\n * @public\n *\n * Returns the type of the data.\n */\nDataMan.prototype.type = function dataManType() {\n  return this._type;\n};\n\n/**\n * @method dataURItoBlob\n * @private\n * @param {String} dataURI The data URI\n * @param {String} dataTYPE The content type\n * @returns {Blob} A new Blob instance\n *\n * Converts a data URI to a Blob.\n */\nfunction dataURItoBlob(dataURI, dataTYPE) {\n  var str = atob(dataURI.split(',')[1]), array = [];\n  for(var i = 0; i < str.length; i++) array.push(str.charCodeAt(i));\n  return new Blob([new Uint8Array(array)], {type: dataTYPE});\n}\n\n/**\n * @method defaultCallback\n * @private\n * @param {Error} [err]\n * @returns {undefined}\n *\n * Can be used as a default callback for client methods that need a callback.\n * Simply throws the provided error if there is one.\n */\nfunction defaultCallback(err) {\n  if (err) {\n    // Show gentle error if Meteor error\n    if (err instanceof Meteor.Error) {\n      console.error(err.message);\n    } else {\n      // Normal error, just throw error\n      throw err;\n    }\n\n  }\n}\n"]}