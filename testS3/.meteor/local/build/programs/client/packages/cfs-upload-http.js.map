)]}'
{"version":3,"file":"/packages/cfs-upload-http.js","sources":["cfs-upload-http/http-call-client.js","cfs-upload-http/upload-http-common.js","cfs-upload-http/upload-http-client.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,E;AACA,0E;AACA,6E;AACA,4B;AACA,G;;AAEA,qD;;AAEA,yC;;AAEA,oD;AACA,oD;AACA,uB;AACA,mB;AACA,G;;AAEA,0B;;AAEA,qC;AACA,oB;AACA,6E;;AAEA,wC;;AAEA,mB;;AAEA,gC;AACA,qB;AACA,2C;AACA,iD;AACA,G;;AAEA,sC;AACA,uD;AACA,oC;AACA,M;AACA,qC;;AAEA,+C;AACA,gD;AACA,gD;;AAEA,wC;AACA,6E;;AAEA,yB;AACA,qB;AACA,6C;AACA,qB;AACA,+E;AACA,mD;AACA,kD;AACA,G;;AAEA,wB;AACA,4C;AACA,G;;AAEA,oD;;AAEA,yC;;AAEA,oE;AACA,oE;AACA,kC;AACA,sC;AACA,4B;AACA,kC;AACA,gC;AACA,M;AACA,e;;AAEA,8C;AACA,uC;;;AAGA,gC;;AAEA,oE;AACA,qE;AACA,a;AACA,O;AACA,uB;AACA,Y;AACA,8C;AACA,iC;AACA,kD;AACA,0D;AACA,Q;AACA,4D;;AAEA,oD;;AAEA,kD;AACA,sC;AACA,wB;AACA,kD;AACA,uC;AACA,6B;AACA,Y;AACA,8C;AACA,K;;AAEA,0B;AACA,0C;;;AAGA,oB;AACA,0B;AACA,c;AACA,0B;AACA,4C;AACA,yB;AACA,oB;AACA,0B;AACA,M;;AAEA,2B;AACA,4C;AACA,6C;AACA,kB;AACA,qC;;AAEA,wB;AACA,yC;AACA,kC;AACA,6B;AACA,yC;AACA,gB;;AAEA,4B;AACA,2C;;AAEA,sD;;AAEA,iE;AACA,oC;AACA,4E;AACA,iB;AACA,sC;AACA,2B;AACA,0B;AACA,a;AACA,W;;AAEA,kE;AACA,0I;AACA,4C;AACA,sC;AACA,kD;AACA,2C;AACA,sC;AACA,a;AACA,8B;AACA,W;;AAEA,kC;;AAEA,gC;AACA,uD;;AAEA,wD;AACA,Y;AACA,yD;AACA,gE;AACA,qE;AACA,mB;AACA,gE;AACA,Y;AACA,qE;AACA,mE;AACA,sE;AACA,sE;AACA,wC;AACA,yE;AACA,wB;AACA,qE;;AAEA,sD;AACA,qD;AACA,kD;AACA,oC;AACA,0D;AACA,a;;AAEA,iC;;AAEA,2B;AACA,yC;AACA,6E;;AAEA,oC;AACA,S;AACA,O;AACA,M;;AAEA,yB;AACA,sB;;AAEA,iB;AACA,kB;AACA,G;;AAEA,E;;AAEA,sE;AACA,uC;AACA,sD;;AAEA,oC;AACA,8B;;AAEA,mB;AACA,wB;AACA,wC;AACA,sB;AACA,mB;AACA,kB;AACA,G;;AAEA,8B;AACA,qB;AACA,uB;;AAEA,a;AACA,E;;AAEA,iC;AACA,e;AACA,gD;AACA,mB;AACA,oB;AACA,0D;AACA,K;AACA,2C;AACA,E;;AAEA,8B;AACA,kF;AACA,E;;AAEA,mD;AACA,+E;;AAEA,wC;AACA,oE;AACA,I;;AAEA,8C;AACA,c;AACA,uE;;AAEA,4B;AACA,E;;AAEA,uD;AACA,mC;AACA,2D;AACA,gE;AACA,gC;AACA,4E;;AAEA,wE;AACA,iF;AACA,S;AACA,mD;AACA,mB;AACA,2B;AACA,K;AACA,U;AACA,yB;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;AChRA,wB;;;;;;;;;;;;;;;;;;;ACAA,E;AACA,6B;AACA,G;;AAEA,gC;AACA,sG;AACA,uC;;AAEA,G;AACA,W;AACA,uB;AACA,yB;AACA,sB;AACA,G;AACA,yC;AACA,uK;AACA,2F;AACA,c;AACA,qD;AACA,Y;;AAEA,sE;;AAEA,iC;AACA,uE;AACA,sB;AACA,kB;AACA,6C;AACA,S;AACA,kC;AACA,oB;AACA,oB;AACA,6D;AACA,gB;AACA,iB;AACA,S;AACA,S;;AAEA,K;AACA,K;AACA,E;;AAEA,G;AACA,W;AACA,uB;AACA,4B;AACA,sB;AACA,G;AACA,6C;AACA,qC;AACA,E;;AAEA,+B;AACA,iC;AACA,e;AACA,4B;AACA,G;AACA,yC;AACA,gB;AACA,0B;;AAEA,yB;AACA,6B;AACA,oC;AACA,iC;AACA,qB;AACA,mB;AACA,wB;AACA,oB;AACA,oB;AACA,gB;AACA,e;AACA,K;;AAEA,gD;AACA,kB;;AAEA,iC;AACA,2B;;AAEA,K;AACA,iD;AACA,yD;AACA,sD;AACA,K;AACA,8E;AACA,M;AACA,4C;AACA,wC;AACA,2H;AACA,I;;AAEA,qD;AACA,8C;AACA,6D;AACA,K;AACA,gD;AACA,wC;AACA,wC;AACA,0D;AACA,K;;AAEA,8B;AACA,wD;AACA,2D;AACA,oF;AACA,8D;AACA,+B;AACA,+B;AACA,K;AACA,I;;AAEA,4C;AACA,oC;AACA,2F;AACA,mF;AACA,K;AACA,uC;AACA,+C;;AAEA,wC;AACA,wC;AACA,0D;AACA,K;;AAEA,4C;AACA,6C;AACA,2E;AACA,K;;AAEA,+E;AACA,gE;AACA,a;AACA,K;;AAEA,2D;AACA,8B;;AAEA,kD;AACA,2B;;AAEA,wF;AACA,gH;AACA,wC;AACA,6B;AACA,kC;AACA,uE;;AAEA,iC;AACA,e;;AAEA,8B;AACA,sG;AACA,yH;;AAEA,2B;AACA,uC;AACA,gD;AACA,qD;AACA,iD;AACA,U;AACA,kC;AACA,yB;AACA,uB;AACA,4B;AACA,yB;AACA,wB;AACA,mB;AACA,S;;AAEA,oC;AACA,4C;;AAEA,8B;AACA,8C;;AAEA,oD;AACA,oE;AACA,4C;;AAEA,sB;AACA,yD;AACA,e;AACA,wB;AACA,O;;AAEA,4E;AACA,yB;AACA,4C;AACA,0B;AACA,wD;AACA,U;;AAEA,4B;AACA,oD;AACA,gD;AACA,O;;AAEA,+B;AACA,uB;AACA,gC;AACA,Q;AACA,6B;AACA,oC;AACA,O;;AAEA,+B;AACA,qE;AACA,0C;AACA,kC;AACA,qF;AACA,gC;AACA,wB;AACA,uB;AACA,+B;AACA,mB;AACA,+B;AACA,2B;AACA,uB;AACA,8C;AACA,W;AACA,O;;AAEA,+C;AACA,2B;AACA,K;;AAEA,I;;AAEA,c;AACA,E;;AAEA,G;AACA,gB;AACA,4B;AACA,E;AACA,oE;AACA,G;AACA,gD;;AAEA,E;AACA,qB;AACA,G;;AAEA,G;AACA,mC;AACA,U;AACA,gC;AACA,4C;AACA,E;AACA,oD;AACA,G;AACA,0C;AACA,kB;AACA,2C;AACA,E","sourcesContent":["/*\n * We use this instead of HTTP.call from the http package for now. If/when\n * PR 1670 is merged and released, we can probably remove this file and begin\n * using HTTP.call directly.\n */\n\nhttpCall = function(method, url, options, callback) {\n\n  ////////// Process arguments //////////\n\n  if (! callback && typeof options === \"function\") {\n    // support (method, url, callback) argument list\n    callback = options;\n    options = null;\n  }\n\n  options = options || {};\n\n  if (typeof callback !== \"function\")\n    throw new Error(\n      \"Can't make a blocking HTTP call from the client; callback required.\");\n\n  method = (method || \"\").toUpperCase();\n\n  var headers = {};\n\n  var content = options.content;\n  if (options.data) {\n    content = JSON.stringify(options.data);\n    headers['Content-Type'] = 'application/json';\n  }\n\n  var params_for_url, params_for_body;\n  if (content || method === \"GET\" || method === \"HEAD\")\n    params_for_url = options.params;\n  else\n    params_for_body = options.params;\n\n  var query_match = /^(.*?)(\\?.*)?$/.exec(url);\n  url = buildUrl(query_match[1], query_match[2],\n                 options.query, params_for_url);\n\n  if (options.followRedirects === false)\n    throw new Error(\"Option followRedirects:false not supported on client.\");\n\n  var username, password;\n  if (options.auth) {\n    var colonLoc = options.auth.indexOf(':');\n    if (colonLoc < 0)\n      throw new Error('auth option should be of the form \"username:password\"');\n    username = options.auth.substring(0, colonLoc);\n    password = options.auth.substring(colonLoc+1);\n  }\n\n  if (params_for_body) {\n    content = encodeParams(params_for_body);\n  }\n\n  FS.Utility.extend(headers, options.headers || {});\n\n  ////////// Callback wrapping //////////\n\n  // wrap callback to add a 'response' property on an error, in case\n  // we have both (http 4xx/5xx error, which has a response payload)\n  callback = (function(callback) {\n    return function(error, response) {\n      if (error && response)\n        error.response = response;\n      callback(error, response);\n    };\n  })(callback);\n\n  // safety belt: only call the callback once.\n  callback = FS.Utility.once(callback);\n\n\n  ////////// Kickoff! //////////\n\n  // from this point on, errors are because of something remote, not\n  // something we should check in advance. Turn exceptions into error\n  // results.\n  try {\n    // setup XHR object\n    var xhr;\n    if (typeof XMLHttpRequest !== \"undefined\")\n      xhr = new XMLHttpRequest();\n    else if (typeof ActiveXObject !== \"undefined\")\n      xhr = new ActiveXObject(\"Microsoft.XMLHttp\"); // IE6\n    else\n      throw new Error(\"Can't create XMLHttpRequest\"); // ???\n\n    xhr.open(method, url, true, username, password);\n\n    // support custom \"ejson-binary\" response type\n    // and all browser-supported types\n    var convertToBinary;\n    if (options.responseType === \"ejson-binary\") {\n      xhr.responseType = \"arraybuffer\";\n      convertToBinary = true;\n    } else {\n      xhr.responseType = options.responseType;\n    }\n\n    for (var k in headers)\n      xhr.setRequestHeader(k, headers[k]);\n\n\n    // setup timeout\n    var timed_out = false;\n    var timer;\n    if (options.timeout) {\n      timer = Meteor.setTimeout(function() {\n        timed_out = true;\n        xhr.abort();\n      }, options.timeout);\n    };\n\n    // callback on complete\n    xhr.onreadystatechange = function(evt) {\n      if (xhr.readyState === 4) { // COMPLETE\n        if (timer)\n          Meteor.clearTimeout(timer);\n\n        if (timed_out) {\n          callback(new Error(\"timeout\"));\n        } else if (! xhr.status) {\n          // no HTTP response\n          callback(new Error(\"network\"));\n        } else {\n\n          var response = {};\n          response.statusCode = xhr.status;\n\n          var body = xhr.response || xhr.responseText;\n\n          // Some browsers don't yet support \"json\" responseType,\n          // but we can replicate it\n          if (options.responseType === \"json\" && typeof body === \"string\") {\n            try {\n              body = JSON.parse(body);\n            } catch (err) {\n              body = null;\n            }\n          }\n\n          // Add support for a custom responseType: \"ejson-binary\"\n          if (convertToBinary && typeof ArrayBuffer !== \"undefined\" && typeof Uint8Array !== \"undefined\" && body instanceof ArrayBuffer) {\n            var view = new Uint8Array(body);\n            var len = body.byteLength;\n            var binaryBody = EJSON.newBinary(len);\n            for (var i = 0; i < len; i++) {\n              binaryBody[i] = view[i];\n            }\n            body = binaryBody;\n          }\n\n          response.content = body;\n\n          response.headers = {};\n          var header_str = xhr.getAllResponseHeaders();\n\n          // https://github.com/meteor/meteor/issues/553\n          //\n          // In Firefox there is a weird issue, sometimes\n          // getAllResponseHeaders returns the empty string, but\n          // getResponseHeader returns correct results. Possibly this\n          // issue:\n          // https://bugzilla.mozilla.org/show_bug.cgi?id=608735\n          //\n          // If this happens we can't get a full list of headers, but\n          // at least get content-type so our JSON decoding happens\n          // correctly. In theory, we could try and rescue more header\n          // values with a list of common headers, but content-type is\n          // the only vital one for now.\n          if (\"\" === header_str && xhr.getResponseHeader(\"content-type\"))\n            header_str =\n            \"content-type: \" + xhr.getResponseHeader(\"content-type\");\n\n          var headers_raw = header_str.split(/\\r?\\n/);\n          FS.Utility.each(headers_raw, function (h) {\n            var m = /^(.*?):(?:\\s+)(.*)$/.exec(h);\n            if (m && m.length === 3)\n              response.headers[m[1].toLowerCase()] = m[2];\n          });\n\n          populateData(response);\n\n          var error = null;\n          if (response.statusCode >= 400)\n            error = makeErrorByStatus(response.statusCode, response.content);\n\n          callback(error, response);\n        }\n      }\n    };\n\n    // send it on its way\n    xhr.send(content);\n\n  } catch (err) {\n    callback(err);\n  }\n\n};\n\nbuildUrl = function(before_qmark, from_qmark, opt_query, opt_params) {\n  var url_without_query = before_qmark;\n  var query = from_qmark ? from_qmark.slice(1) : null;\n\n  if (typeof opt_query === \"string\")\n    query = String(opt_query);\n\n  if (opt_params) {\n    query = query || \"\";\n    var prms = encodeParams(opt_params);\n    if (query && prms)\n      query += '&';\n    query += prms;\n  }\n\n  var url = url_without_query;\n  if (query !== null)\n    url += (\"?\"+query);\n\n  return url;\n};\n\nencodeParams = function(params) {\n  var buf = [];\n  FS.Utility.each(params, function(value, key) {\n    if (buf.length)\n      buf.push('&');\n    buf.push(encodeString(key), '=', encodeString(value));\n  });\n  return buf.join('').replace(/%20/g, '+');\n};\n\nencodeString = function(str) {\n  return encodeURIComponent(str).replace(/[!'()]/g, escape).replace(/\\*/g, \"%2A\");\n};\n\nmakeErrorByStatus = function(statusCode, content) {\n  var MAX_LENGTH = 160; // if you change this, also change the appropriate test\n\n  var truncate = function(str, length) {\n    return str.length > length ? str.slice(0, length) + '...' : str;\n  };\n\n  var message = \"failed [\" + statusCode + \"]\";\n  if (content)\n    message += \" \" + truncate(content.replace(/\\n/g, \" \"), MAX_LENGTH);\n\n  return new Error(message);\n};\n\n// Fill in `response.data` if the content-type is JSON.\npopulateData = function(response) {\n  // Read Content-Type header, up to a ';' if there is one.\n  // A typical header might be \"application/json; charset=utf-8\"\n  // or just \"application/json\".\n  var contentType = (response.headers['content-type'] || ';').split(';')[0];\n\n  // Only try to parse data as JSON if server sets correct content type.\n  if (FS.Utility.include(['application/json', 'text/javascript'], contentType)) {\n    try {\n      response.data = JSON.parse(response.content);\n    } catch (err) {\n      response.data = null;\n    }\n  } else {\n    response.data = null;\n  }\n};\n","FS.HTTP = FS.HTTP || {};\n","/*\n * HTTP Upload Transfer Queue\n */\n\n// 2MB default upload chunk size\n// Can be overridden by user with FS.config.uploadChunkSize or per FS.Collection in collection options\nvar defaultChunkSize = 2 * 1024 * 1024;\n\n/**\n * @private\n * @param {Object} task\n * @param {Function} next\n * @return {undefined}\n */\nvar _taskHandler = function(task, next) {\n  FS.debug && console.log(\"uploading chunk \" + task.chunk + \", bytes \" + task.start + \" to \" + Math.min(task.end, task.fileObj.size()) + \" of \" + task.fileObj.size());\n  task.fileObj.data.getBinary(task.start, task.end, function gotBinaryCallback(err, data) {\n    if (err) {\n      next(new Meteor.Error(err.error, err.message));\n    } else {\n\n      FS.debug && console.log('PUT to URL', task.url, task.urlParams);\n\n      httpCall(\"PUT\", task.url, {\n        params: FS.Utility.extend({chunk: task.chunk}, task.urlParams),\n        content: data,\n        headers: {\n          'Content-Type': task.fileObj.type()\n        }\n      }, function(error, result) {\n        task = null;\n        if (error) {\n          next(new Meteor.Error(error.error, error.message));\n        } else {\n          next();\n        }\n      });\n\n    }\n  });\n};\n\n/**\n * @private\n * @param {Object} data\n * @param {Function} addTask\n * @return {undefined}\n */\nvar _errorHandler = function(data, addTask) {\n  // What to do if file upload fails?\n};\n\n/** @method UploadTransferQueue\n * @namespace UploadTransferQueue\n * @constructor\n * @param {Object} [options]\n */\nUploadTransferQueue = function(options) {\n  // Rig options\n  options = options || {};\n\n  // Init the power queue\n  var self = new PowerQueue({\n    name: 'HTTPUploadTransferQueue',\n    // spinalQueue: ReactiveList,\n    maxProcessing: 1,\n    maxFailures: 5,\n    jumpOnFailure: true,\n    autostart: true,\n    isPaused: false,\n    filo: false,\n    debug: true\n  });\n\n  // Keep track of uploaded files via this queue\n  self.files = {};\n\n  // cancel maps onto queue reset\n  self.cancel = self.reset;\n\n  /**\n    * @method UploadTransferQueue.isUploadingFile\n    * @param {FS.File} fileObj File to check if uploading\n    * @returns {Boolean} True if the file is uploading\n    *\n    * @todo Maybe have a similar function for accessing the file upload queue?\n    */\n  self.isUploadingFile = function(fileObj) {\n    // Check if file is already in queue\n    return !!(fileObj && fileObj._id && fileObj.collectionName && (self.files[fileObj.collectionName] || {})[fileObj._id]);\n  };\n\n  /** @method UploadTransferQueue.resumeUploadingFile\n   * @param {FS.File} File to resume uploading\n   * @todo Not sure if this is the best way to handle resumes\n   */\n  self.resumeUploadingFile = function(fileObj) {\n    // Make sure we are handed a FS.File\n    if (!(fileObj instanceof FS.File)) {\n      throw new Error('Transfer queue expects a FS.File');\n    }\n\n    if (fileObj.isMounted()) {\n      // This might still be true, preventing upload, if\n      // there was a server restart without client restart.\n      self.files[fileObj.collectionName] = self.files[fileObj.collectionName] || {};\n      self.files[fileObj.collectionName][fileObj._id] = false;\n      // Kick off normal upload\n      self.uploadFile(fileObj);\n    }\n  };\n\n  /** @method UploadTransferQueue.uploadFile\n   * @param {FS.File} File to upload\n   * @todo Check that a file can only be added once - maybe a visual helper on the FS.File?\n   * @todo Have an initial request to the server getting uploaded chunks for resume\n   */\n  self.uploadFile = function(fileObj) {\n    FS.debug && console.log(\"HTTP uploadFile\");\n\n    // Make sure we are handed a FS.File\n    if (!(fileObj instanceof FS.File)) {\n      throw new Error('Transfer queue expects a FS.File');\n    }\n\n    // Make sure that we have size as number\n    if (typeof fileObj.size() !== 'number') {\n      throw new Error('TransferQueue upload failed: fileObj size not set');\n    }\n\n    // We don't add the file if it's already in transfer or if already uploaded\n    if (self.isUploadingFile(fileObj) || fileObj.isUploaded()) {\n      return;\n    }\n\n    // Make sure the file object is mounted on a collection\n    if (fileObj.isMounted()) {\n\n      var collectionName = fileObj.collectionName;\n      var id = fileObj._id;\n\n      // Set the chunkSize to match the collection options, or global config, or default\n      fileObj.chunkSize = fileObj.collection.options.chunkSize || FS.config.uploadChunkSize || defaultChunkSize;\n      // Set counter for uploaded chunks\n      fileObj.chunkCount = 0;\n      // Calc the number of chunks\n      fileObj.chunkSum = Math.ceil(fileObj.size() / fileObj.chunkSize);\n\n      if (fileObj.chunkSum === 0)\n        return;\n\n      // Update the filerecord\n      // TODO eventually we should be able to do this without storing any chunk info in the filerecord\n      fileObj.update({$set: {chunkSize: fileObj.chunkSize, chunkCount: fileObj.chunkCount, chunkSum: fileObj.chunkSum}});\n\n      // Create a sub queue\n      var chunkQueue = new PowerQueue({\n        onEnded: function oneChunkQueueEnded() {\n          // Remove from list of files being uploaded\n          self.files[collectionName][id] = false;\n        },\n        spinalQueue: ReactiveList,\n        maxProcessing: 1,\n        maxFailures: 5,\n        jumpOnFailure: true,\n        autostart: false,\n        isPaused: false,\n        filo: false\n      });\n\n      // Rig the custom task handler\n      chunkQueue.taskHandler = _taskHandler;\n\n      // Rig the error handler\n      chunkQueue.errorHandler = _errorHandler;\n\n      // Set flag that this file is being transfered\n      self.files[collectionName] = self.files[collectionName] || {};\n      self.files[collectionName][id] = true;\n\n      // Construct URL\n      var url = FS.HTTP.uploadUrl + '/' + collectionName;\n      if (id) {\n        url += '/' + id;\n      }\n\n      // TODO: Could we somehow figure out if the collection requires login?\n      var authToken = '';\n      if (typeof Accounts !== \"undefined\") {\n        var authObject = {\n          authToken: Accounts._storedLoginToken() || '',\n        };\n\n        // Set the authToken\n        var authString = JSON.stringify(authObject);\n        authToken = FS.Utility.btoa(authString);\n      }\n\n      // Construct query string\n      var urlParams = {\n        filename: fileObj.name()\n      };\n      if (authToken !== '') {\n        urlParams.token = authToken;\n      }\n\n      // Add chunk upload tasks\n      for (var chunk = 0, start; chunk < fileObj.chunkSum; chunk++) {\n        start = chunk * fileObj.chunkSize;\n        // Create and add the task\n        // XXX should we somehow make sure we haven't uploaded this chunk already, in\n        // case we are resuming?\n        chunkQueue.add({\n          chunk: chunk,\n          name: fileObj.name(),\n          url: url,\n          urlParams: urlParams,\n          fileObj: fileObj,\n          start: start,\n          end: (chunk + 1) * fileObj.chunkSize\n        });\n      }\n\n      // Add the queue to the main upload queue\n      self.add(chunkQueue);\n    }\n\n  };\n\n  return self;\n};\n\n/**\n * @namespace FS\n * @type UploadTransferQueue\n *\n * There is a single uploads transfer queue per client (not per CFS)\n */\nFS.HTTP.uploadQueue = new UploadTransferQueue();\n\n/*\n * FS.File extensions\n */\n\n/**\n * @method FS.File.prototype.resume\n * @public\n * @param {File|Blob|Buffer} ref\n * @todo WIP, Not yet implemented for server\n *\n * > This function is not yet implemented for server\n */\nFS.File.prototype.resume = function(ref) {\n  var self = this;\n  FS.uploadQueue.resumeUploadingFile(self);\n};\n"]}